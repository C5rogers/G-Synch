// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: table.sql

package pg_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getColumns = `-- name: GetColumns :many
  SELECT
	     column_name as column_name,
	     data_type as data_type,
	     is_nullable as is_nullable,
	     column_default as column_default
	 FROM information_schema.columns
	 WHERE table_schema = $1 AND table_name = $2
	 ORDER BY ordinal_position
`

type GetColumnsParams struct {
	SchemaName pgtype.Text `json:"schema_name"`
	TableName  pgtype.Text `json:"table_name"`
}

type GetColumnsRow struct {
	ColumnName    interface{} `json:"column_name"`
	DataType      interface{} `json:"data_type"`
	IsNullable    interface{} `json:"is_nullable"`
	ColumnDefault interface{} `json:"column_default"`
}

func (q *Queries) GetColumns(ctx context.Context, arg GetColumnsParams) ([]GetColumnsRow, error) {
	rows, err := q.db.Query(ctx, getColumns, arg.SchemaName, arg.TableName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetColumnsRow
	for rows.Next() {
		var i GetColumnsRow
		if err := rows.Scan(
			&i.ColumnName,
			&i.DataType,
			&i.IsNullable,
			&i.ColumnDefault,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForeignKeys = `-- name: GetForeignKeys :many
  SELECT
      kcu.column_name AS column_name,
      ccu.table_name AS foreign_table_name,
      ccu.column_name AS foreign_column_name,
      tc.table_schema AS foreign_table_schema
  FROM
      information_schema.table_constraints AS tc
      JOIN information_schema.key_column_usage AS kcu
        ON tc.constraint_name = kcu.constraint_name
        AND tc.table_schema = kcu.table_schema
      JOIN information_schema.constraint_column_usage AS ccu
        ON ccu.constraint_name = tc.constraint_name
        AND ccu.table_schema = tc.table_schema
  WHERE tc.constraint_type = 'FOREIGN KEY' AND tc.table_name = $1
`

type GetForeignKeysRow struct {
	ColumnName         interface{} `json:"column_name"`
	ForeignTableName   interface{} `json:"foreign_table_name"`
	ForeignColumnName  interface{} `json:"foreign_column_name"`
	ForeignTableSchema interface{} `json:"foreign_table_schema"`
}

func (q *Queries) GetForeignKeys(ctx context.Context, tableName pgtype.Text) ([]GetForeignKeysRow, error) {
	rows, err := q.db.Query(ctx, getForeignKeys, tableName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetForeignKeysRow
	for rows.Next() {
		var i GetForeignKeysRow
		if err := rows.Scan(
			&i.ColumnName,
			&i.ForeignTableName,
			&i.ForeignColumnName,
			&i.ForeignTableSchema,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryKeys = `-- name: GetPrimaryKeys :many
  SELECT
      kcu.column_name as column_name
  FROM
      information_schema.table_constraints AS tc
      JOIN information_schema.key_column_usage AS kcu
        ON tc.constraint_name = kcu.constraint_name
        AND tc.table_schema = kcu.table_schema
  WHERE tc.constraint_type = 'PRIMARY KEY' AND tc.table_schema = $1 AND tc.table_name = $2
  ORDER BY kcu.ordinal_position
`

type GetPrimaryKeysParams struct {
	SchemaName pgtype.Text `json:"schema_name"`
	TableName  pgtype.Text `json:"table_name"`
}

func (q *Queries) GetPrimaryKeys(ctx context.Context, arg GetPrimaryKeysParams) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, getPrimaryKeys, arg.SchemaName, arg.TableName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var column_name interface{}
		if err := rows.Scan(&column_name); err != nil {
			return nil, err
		}
		items = append(items, column_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTables = `-- name: GetTables :many
  SELECT
      table_name as table_name
  FROM
      information_schema.tables
  WHERE table_schema = $1
`

func (q *Queries) GetTables(ctx context.Context, schemaName pgtype.Text) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, getTables, schemaName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var table_name interface{}
		if err := rows.Scan(&table_name); err != nil {
			return nil, err
		}
		items = append(items, table_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
